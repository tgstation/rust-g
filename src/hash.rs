use crate::error::{Error, Result};
use base64::Engine;
use const_random::const_random;
const XXHASH_SEED: u64 = const_random!(u64);
use hmac::{Hmac, Mac};
use md5::Md5;
use rand::{distr::Alphanumeric, Rng, RngCore, SeedableRng};
use rand_chacha::ChaCha20Rng;
use sha1::Sha1;
use sha2::{Digest, Sha256, Sha512};
use std::{
    cell::RefCell,
    convert::TryInto,
    fs::File,
    hash::Hasher,
    io::Read,
    time::{SystemTime, UNIX_EPOCH},
};
use twox_hash::XxHash64;

const TOTP_DIGITS: usize = 6;
const TOTP_STEP_SECONDS: u64 = 30;
const DIGITS_POWER: [u32; 9] = [
    1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000,
];

byond_fn!(fn hash_string(algorithm, string) {
    string_hash(algorithm, string).ok()
});

byond_fn!(fn decode_base64(string) {
    Some(base64::prelude::BASE64_STANDARD.decode(string).unwrap())
});

byond_fn!(fn decode_base32(string, padding) {
    Some(base32::decode(base32::Alphabet::Rfc4648 { padding: padding == "1" }, string).unwrap())
});

byond_fn!(fn hash_file(algorithm, string) {
    file_hash(algorithm, string).ok()
});

byond_fn!(fn generate_totp(algorithm, base32_seed) {
    match totp_generate(algorithm, base32_seed, 0, TOTP_DIGITS, None) {
        Ok(value) => Some(value),
        Err(error) => Some(format!("ERROR: {error:?}"))
    }
});

byond_fn!(fn csprng_chacha20(format, n_bytes) {
    let n_bytes: usize = match n_bytes.parse() {
        Ok(n) => n,
        Err(_) => return Some(String::from("ERROR: Unparseable n_bytes"))
    };
    if n_bytes < 1 {
        return Some(String::from("ERROR: Zero bytes not allowed"))
    }
    Some(gen_csprng_chacha20(format, n_bytes))
});

fn gen_csprng_chacha20(format: &str, n_bytes: usize) -> String {
    // Seed is generated by underlying OS random source (Linux: syscall to getrandom, /dev/urandom, Win: ProcessPrng)
    // The seed is presumably cryptographically secure as it is provided by hardware source.
    // This makes the RNG output non-deterministic and suitable for use in cryptography.
    let mut rng = ChaCha20Rng::from_os_rng();
    format_rng(&mut rng, format, n_bytes)
}

byond_fn!(fn prng_chacha20_seeded(format, n_bytes, seed) {
    let n_bytes: usize = match n_bytes.parse() {
        Ok(n) => n,
        Err(_) => return Some(String::from("ERROR: Unparseable n_bytes"))
    };
    if n_bytes < 1 {
        return Some(String::from("ERROR: Zero bytes not allowed"))
    }
    Some(gen_prng_chacha20_seeded(format, n_bytes, seed))
});

fn gen_prng_chacha20_seeded(format: &str, n_bytes: usize, seed: &str) -> String {
    // SHA256 hash the seed and provide the raw SHA256 output bytes to the hasher.
    // This normalizes the seed's distribution of 0 and 1s, making it produce higher quality randomness.
    // It also normalizes the length of the seed to 32 bytes.
    let mut seed_hasher = Sha256::new();
    seed_hasher.update(seed.as_bytes());
    let hashed_seed: [u8; 32] = seed_hasher.finalize().into();
    let mut rng = ChaCha20Rng::from_seed(hashed_seed);
    format_rng(&mut rng, format, n_bytes)
}

fn format_rng<T: RngCore>(rng: &mut T, format: &str, n_bytes: usize) -> String {
    match format {
        "alphanumeric" => (0..n_bytes)
            .map(|_| rng.sample(Alphanumeric) as char)
            .collect::<String>(),
        "hex" => {
            let mut bytes = vec![0u8; n_bytes];
            rng.fill_bytes(&mut bytes);
            hex::encode(bytes)
        }
        "base32_rfc4648" => {
            let mut bytes = vec![0u8; n_bytes];
            rng.fill_bytes(&mut bytes);
            base32::encode(base32::Alphabet::Rfc4648 { padding: false }, &bytes)
        }
        "base32_rfc4648_pad" => {
            let mut bytes = vec![0u8; n_bytes];
            rng.fill_bytes(&mut bytes);
            base32::encode(base32::Alphabet::Rfc4648 { padding: true }, &bytes)
        }
        "base64" => {
            let mut bytes = vec![0u8; n_bytes];
            rng.fill_bytes(&mut bytes);
            base64::prelude::BASE64_STANDARD.encode(bytes)
        }
        _ => String::from("ERROR: Invalid format"),
    }
}

byond_fn!(fn generate_totp_tolerance(algorithm, base32_seed, tolerance) {
    let tolerance_value: i32 = match tolerance.parse() {
        Ok(value) => value,
        Err(_) => return Some(String::from("ERROR: Tolerance not a valid integer"))
    };
    match totp_generate_tolerance(algorithm, base32_seed, tolerance_value, TOTP_DIGITS, None) {
        Ok(value) => Some(value),
        Err(error) => Some(format!("ERROR: {error:?}"))
    }
});

pub fn string_hash(algorithm: &str, string: &str) -> Result<String> {
    let mut hasher = HashDispatcher::new(algorithm)?;
    hasher.update(string);
    Ok(hasher.finish())
}

const BUFFER_SIZE: usize = 65536;
// don't allocate another buffer every time we hash a file, just reuse the same buffer.
thread_local!( static FILE_HASH_BUFFER: RefCell<[u8; BUFFER_SIZE]> = const { RefCell::new([0; BUFFER_SIZE]) } );

pub fn file_hash(algorithm: &str, path: &str) -> Result<String> {
    let mut hasher = HashDispatcher::new(algorithm)?;
    let mut file = File::open(path)?;

    FILE_HASH_BUFFER.with_borrow_mut(|buffer| {
        loop {
            let bytes_read = file.read(buffer)?;
            if bytes_read == 0 {
                break;
            }
            hasher.update(&buffer[..bytes_read]);
        }
        Ok(hasher.finish())
    })
}

/// Generates multiple TOTP codes from base32_seed, with time step +-tolerance
/// time_override is used as the current unix time instead of the current system time for testing
fn totp_generate_tolerance(
    algorithm: &str,
    base32_seed: &str,
    tolerance: i32,
    digits: usize,
    time_override: Option<u64>,
) -> Result<String> {
    let mut results: Vec<String> = Vec::new();
    for i in -tolerance..(tolerance + 1) {
        let result = totp_generate(algorithm, base32_seed, i.into(), digits, time_override)?;
        results.push(result)
    }
    Ok(serde_json::to_string(&results)?)
}

fn hmac<D>(seed: &[u8], data: &[u8]) -> Vec<u8>
where
    D: Mac + hmac::digest::KeyInit,
{
    let mut mac = <D as Mac>::new_from_slice(seed).unwrap();
    mac.update(data);
    mac.finalize().into_bytes().to_vec()
}

/// Generates a single TOTP code from base32_seed offset by offset time steps
/// base32_seed should be at least 16 input bytes, 128 bits, but is recommended to be 20 input bytes, 160 bits
/// Please use a proper hardware-seeded CSPRNG to seed the TOTP and store it in a secure location.
/// Maximum usable length of seed is 104 characters (64 bytes, 512 bits)
/// time_override is used as the current unix time instead of the current system time for testing
/// TOTP algorithm described https://blogs.unimelb.edu.au/sciencecommunication/2021/09/30/totp/
fn totp_generate(
    algorithm: &str,
    base32_seed: &str,
    offset: i64,
    digits: usize,
    time_override: Option<u64>,
) -> Result<String> {
    let mut seed: [u8; 64] = [0; 64];

    if !(1..=8).contains(&digits) {
        return Err(Error::BadDigits);
    }

    // Always accept padding
    match base32::decode(base32::Alphabet::Rfc4648 { padding: true }, base32_seed) {
        Some(base32_bytes) => {
            if base32_bytes.len() < 10 || base32_bytes.len() > 64 {
                return Err(Error::BadSeed);
            }
            seed[..base32_bytes.len()].copy_from_slice(&base32_bytes);
        }
        None => return Err(Error::BadSeed),
    }
    // Will panic if the date is not between Jan 1 1970 and the year ~200 billion
    let curr_time: u64 = time_override.unwrap_or_else(|| {
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .expect("SystemTime is before Unix Epoc")
            .as_secs()
    }) / TOTP_STEP_SECONDS;
    let time: u64 = curr_time.saturating_add_signed(offset);
    let time_bytes: [u8; 8] = time.to_be_bytes();

    let hmac_bytes: Vec<u8> = match algorithm {
        "sha1" => hmac::<Hmac<Sha1>>(&seed, &time_bytes),
        "sha256" => hmac::<Hmac<Sha256>>(&seed, &time_bytes),
        "sha512" => hmac::<Hmac<Sha512>>(&seed, &time_bytes),
        _ => return Err(Error::InvalidAlgorithm),
    };

    let totp_byte_offset: usize = (hmac_bytes.last().unwrap() & 0x0F) as usize;
    let totp_bytes: [u8; 4] = hmac_bytes[totp_byte_offset..(totp_byte_offset + 4)]
        .try_into()
        .unwrap();
    let totp_untruncated: u32 = u32::from_be_bytes(totp_bytes);
    let totp_sized_code: u32 = (totp_untruncated & 0x7FFFFFFF) % DIGITS_POWER[digits];
    // Pad the digits in constant time to reduce effectiveness of timing attacks
    let totp_code_str = (10u64.pow(digits as u32)
        + (totp_sized_code as u64 % 10u64.pow(digits as u32)))
    .to_string();
    let totp_code_resized = &totp_code_str.as_bytes()[totp_code_str.len() - digits..];
    // we know that the UTF-8 is valid as it just came from a UTF-8 string.
    // it will only be digits which do not include any multi-byte UTF-8 characters
    unsafe { Ok(String::from_utf8_unchecked(totp_code_resized.to_vec())) }
}

enum HashDispatcher {
    Md5(Md5),
    Sha1(Sha1),
    Sha256(Sha256),
    Sha512(Sha512),
    Xxh64(XxHash64),
    Base32(Vec<u8>),
    Base32Pad(Vec<u8>),
    Base64(Vec<u8>),
}

impl HashDispatcher {
    fn new(name: &str) -> Result<Self> {
        match name {
            "md5" => Ok(Self::Md5(Md5::new())),
            "sha1" => Ok(Self::Sha1(Sha1::new())),
            "sha256" => Ok(Self::Sha256(Sha256::new())),
            "sha512" => Ok(Self::Sha512(Sha512::new())),
            "xxh64" => Ok(Self::Xxh64(XxHash64::with_seed(XXHASH_SEED))),
            "xxh64_fixed" => Ok(Self::Xxh64(XxHash64::with_seed(17479268743136991876))), // this seed is just a random number that should stay the same between builds and runs
            "base32_rfc4648" => Ok(Self::Base32(Vec::new())),
            "base32_rfc4648_pad" => Ok(Self::Base32Pad(Vec::new())),
            "base64" => Ok(Self::Base64(Vec::new())),
            _ => Err(Error::InvalidAlgorithm),
        }
    }

    fn update(&mut self, data: impl AsRef<[u8]>) {
        let data = data.as_ref();
        match self {
            HashDispatcher::Md5(hasher) => hasher.update(data),
            HashDispatcher::Sha1(hasher) => hasher.update(data),
            HashDispatcher::Sha256(hasher) => hasher.update(data),
            HashDispatcher::Sha512(hasher) => hasher.update(data),
            HashDispatcher::Xxh64(hasher) => hasher.write(data),
            HashDispatcher::Base32(buffer) => buffer.extend_from_slice(data),
            HashDispatcher::Base32Pad(buffer) => buffer.extend_from_slice(data),
            HashDispatcher::Base64(buffer) => buffer.extend_from_slice(data),
        }
    }

    fn finish(self) -> String {
        match self {
            HashDispatcher::Md5(hasher) => hex::encode(hasher.finalize()),
            HashDispatcher::Sha1(hasher) => hex::encode(hasher.finalize()),
            HashDispatcher::Sha256(hasher) => hex::encode(hasher.finalize()),
            HashDispatcher::Sha512(hasher) => hex::encode(hasher.finalize()),
            HashDispatcher::Xxh64(hasher) => format!("{:x}", hasher.finish()),
            HashDispatcher::Base32(buffer) => {
                base32::encode(base32::Alphabet::Rfc4648 { padding: false }, &buffer)
            }
            HashDispatcher::Base32Pad(buffer) => {
                base32::encode(base32::Alphabet::Rfc4648 { padding: true }, &buffer)
            }
            HashDispatcher::Base64(buffer) => base64::prelude::BASE64_STANDARD.encode(&buffer),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn totp_generate_test() {
        // https://datatracker.ietf.org/doc/html/rfc6238#autoid-18 Test Vectors
        // See: https://www.rfc-editor.org/errata/eid2866 for seed discrepancy
        const TOTP_TEST_TIMES: [u64; 6] = [
            59,
            1111111109,
            1111111111,
            1234567890,
            2000000000,
            20000000000,
        ];
        const TOTP_TEST_ALGORITHMS: [&'static str; 3] = ["sha1", "sha256", "sha512"];
        const TOTP_TEST_SEEDS: [&'static str; 3] = [
            "12345678901234567890",
            "12345678901234567890123456789012",
            "1234567890123456789012345678901234567890123456789012345678901234",
        ];
        const TOTP_TEST_VALUES_TIME_ALGO: [[&'static str; 3]; 6] = [
            ["94287082", "46119246", "90693936"],
            ["07081804", "68084774", "25091201"],
            ["14050471", "67062674", "99943326"],
            ["89005924", "91819424", "93441116"],
            ["69279037", "90698825", "38618901"],
            ["65353130", "77737706", "47863826"],
        ];
        TOTP_TEST_TIMES
            .iter()
            .enumerate()
            .for_each(|(time_idx, time)| {
                TOTP_TEST_ALGORITHMS
                    .iter()
                    .zip(TOTP_TEST_SEEDS)
                    .enumerate()
                    .for_each(|(algo_idx, (algo, seed))| {
                        let totp = totp_generate(
                            *algo,
                            &base32::encode(
                                base32::Alphabet::Rfc4648 { padding: false }, // test it unpadded
                                seed.as_bytes(),
                            ),
                            0,
                            8,
                            Some(*time),
                        );
                        assert_eq!(
                            totp.unwrap(),
                            TOTP_TEST_VALUES_TIME_ALGO[time_idx][algo_idx]
                        );
                    })
            });

        // The big offset is so that it always uses the same time, allowing for verification that the algorithm is correct
        // Seed, time, and result for zero offset taken from https://blogs.unimelb.edu.au/sciencecommunication/2021/09/30/totp/
        let result = totp_generate(
            "sha1",
            "XE7ZREYZTLXYK444",
            0,
            6,
            Some(54424722u64 * TOTP_STEP_SECONDS + (TOTP_STEP_SECONDS - 1)),
        );
        assert_eq!(result.unwrap(), "417714");
        let result2 = totp_generate(
            "sha1",
            "XE7ZREYZTLXYK444",
            -1,
            6,
            Some(54424722u64 * TOTP_STEP_SECONDS + (TOTP_STEP_SECONDS - 1)),
        );
        assert_eq!(result2.unwrap(), "358747");
        let result3 = totp_generate(
            "sha1",
            "XE7ZREYZTLXYK444",
            1,
            6,
            Some(54424722u64 * TOTP_STEP_SECONDS + (TOTP_STEP_SECONDS - 1)),
        );
        assert_eq!(result3.unwrap(), "539257");
        let result4 = totp_generate(
            "sha1",
            "XE7ZREYZTLXYK444",
            2,
            6,
            Some(54424722u64 * TOTP_STEP_SECONDS + (TOTP_STEP_SECONDS - 1)),
        );
        assert_eq!(result4.unwrap(), "679828");

        let json_result = totp_generate_tolerance(
            "sha1",
            "XE7ZREYZTLXYK444",
            1,
            6,
            Some(54424722u64 * TOTP_STEP_SECONDS + (TOTP_STEP_SECONDS - 1)),
        );
        assert_eq!(json_result.unwrap(), "[\"358747\",\"417714\",\"539257\"]");
        let err_result = totp_generate_tolerance("sha1", "66", 0, 6, None);
        assert!(err_result.is_err());
        let err_result = totp_generate_tolerance("sha1", "XE7ZREYZTLXYK444", 0, 10, None);
        assert!(err_result.is_err());
        let err_result = totp_generate_tolerance("invalid", "XE7ZREYZTLXYK444", 0, 6, None);
        assert!(err_result.is_err());
    }
}
