use crate::error::{Error, Result};
use base64::Engine;
use const_random::const_random;
const XXHASH_SEED: u64 = const_random!(u64);
use hmac::{Hmac, Mac};
use md5::Md5;
use rand::{distr::Alphanumeric, Rng, RngCore, SeedableRng};
use rand_chacha::ChaCha20Rng;
use sha1::Sha1;
use sha2::{Digest, Sha256, Sha512};
use std::{
    convert::TryInto,
    fs::File,
    hash::Hasher,
    io::{BufReader, Read},
    time::{SystemTime, UNIX_EPOCH},
};
use twox_hash::XxHash64;

const TOTP_DIGITS: usize = 6;
const TOTP_STEP_SECONDS: i64 = 30;
const DIGITS_POWER: [u32; 9] = [
    1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000,
];

byond_fn!(fn hash_string(algorithm, string) {
    string_hash(algorithm, string).ok()
});

byond_fn!(fn decode_base64(string) {
    Some(base64::prelude::BASE64_STANDARD.decode(string).unwrap())
});

byond_fn!(fn decode_base32(string) {
    Some(base32::decode(base32::Alphabet::Rfc4648 { padding: true }, string).unwrap())
});

byond_fn!(fn hash_file(algorithm, string) {
    file_hash(algorithm, string).ok()
});

byond_fn!(fn generate_totp(algorithm, base32_seed) {
    match totp_generate(algorithm, base32_seed, 0, TOTP_DIGITS, None) {
        Ok(value) => Some(value),
        Err(error) => Some(format!("ERROR: {error:?}"))
    }
});

byond_fn!(fn csprng_chacha20(format, n_bytes) {
    let n_bytes: usize = match n_bytes.parse() {
        Ok(n) => n,
        Err(_) => return Some(String::from("ERROR: Unparseable n_bytes"))
    };
    if n_bytes < 1 {
        return Some(String::from("ERROR: Zero bytes not allowed"))
    }
    Some(gen_csprng_chacha20(format, n_bytes))
});

fn gen_csprng_chacha20(format: &str, n_bytes: usize) -> String {
    // Seed is generated by underlying OS random source (Linux: syscall to getrandom, /dev/urandom, Win: ProcessPrng)
    // The seed is presumably cryptographically secure as it is provided by hardware source.
    // This makes the RNG output non-deterministic and suitable for use in cryptography.
    let mut rng = ChaCha20Rng::from_os_rng();
    format_rng(&mut rng, format, n_bytes)
}

byond_fn!(fn prng_chacha20_seeded(format, n_bytes, seed) {
    let n_bytes: usize = match n_bytes.parse() {
        Ok(n) => n,
        Err(_) => return Some(String::from("ERROR: Unparseable n_bytes"))
    };
    if n_bytes < 1 {
        return Some(String::from("ERROR: Zero bytes not allowed"))
    }
    Some(gen_prng_chacha20_seeded(format, n_bytes, seed))
});

fn gen_prng_chacha20_seeded(format: &str, n_bytes: usize, seed: &str) -> String {
    // SHA256 hash the seed and provide the raw SHA256 output bytes to the hasher.
    // This normalizes the seed's distribution of 0 and 1s, making it produce higher quality randomness.
    // It also normalizes the length of the seed to 32 bytes.
    let mut seed_hasher = Sha256::new();
    seed_hasher.update(seed.as_bytes());
    let hashed_seed: [u8; 32] = seed_hasher.finalize().into();
    let mut rng = ChaCha20Rng::from_seed(hashed_seed);
    format_rng(&mut rng, format, n_bytes)
}

fn format_rng<T: RngCore>(rng: &mut T, format: &str, n_bytes: usize) -> String {
    match format {
        "alphanumeric" => (0..n_bytes)
            .map(|_| rng.sample(Alphanumeric) as char)
            .collect::<String>(),
        "hex" => {
            let mut bytes = vec![0u8; n_bytes];
            rng.fill_bytes(&mut bytes);
            hex::encode(bytes)
        }
        "base32_rfc4648" => {
            let mut bytes = vec![0u8; n_bytes];
            rng.fill_bytes(&mut bytes);
            base32::encode(base32::Alphabet::Rfc4648 { padding: true }, &bytes)
        }
        "base64" => {
            let mut bytes = vec![0u8; n_bytes];
            rng.fill_bytes(&mut bytes);
            base64::prelude::BASE64_STANDARD.encode(bytes)
        }
        _ => String::from("ERROR: Invalid format"),
    }
}

byond_fn!(fn generate_totp_tolerance(algorithm, base32_seed, tolerance) {
    let tolerance_value: i32 = match tolerance.parse() {
        Ok(value) => value,
        Err(_) => return Some(String::from("ERROR: Tolerance not a valid integer"))
    };
    match totp_generate_tolerance(algorithm, base32_seed, tolerance_value, TOTP_DIGITS, None) {
        Ok(value) => Some(value),
        Err(error) => Some(format!("ERROR: {error:?}"))
    }
});

fn hash_algorithm<B: AsRef<[u8]>>(name: &str, bytes: B) -> Result<String> {
    match name {
        "md5" => {
            let mut hasher = Md5::new();
            hasher.update(bytes.as_ref());
            Ok(hex::encode(hasher.finalize()))
        }
        "sha1" => {
            let mut hasher = Sha1::new();
            hasher.update(bytes.as_ref());
            Ok(hex::encode(hasher.finalize()))
        }
        "sha256" => {
            let mut hasher = Sha256::new();
            hasher.update(bytes.as_ref());
            Ok(hex::encode(hasher.finalize()))
        }
        "sha512" => {
            let mut hasher = Sha512::new();
            hasher.update(bytes.as_ref());
            Ok(hex::encode(hasher.finalize()))
        }
        "xxh64" => {
            let mut hasher = XxHash64::with_seed(XXHASH_SEED);
            hasher.write(bytes.as_ref());
            Ok(format!("{:x}", hasher.finish()))
        }
        "xxh64_fixed" => {
            let mut hasher = XxHash64::with_seed(17479268743136991876); // this seed is just a random number that should stay the same between builds and runs
            hasher.write(bytes.as_ref());
            Ok(format!("{:x}", hasher.finish()))
        }
        "base32" => Ok(base32::encode(
            base32::Alphabet::Rfc4648 { padding: true },
            bytes.as_ref(),
        )),
        "base64" => Ok(base64::prelude::BASE64_STANDARD.encode(bytes.as_ref())),
        _ => Err(Error::InvalidAlgorithm),
    }
}

pub fn string_hash(algorithm: &str, string: &str) -> Result<String> {
    hash_algorithm(algorithm, string)
}

pub fn file_hash(algorithm: &str, path: &str) -> Result<String> {
    let mut bytes: Vec<u8> = Vec::new();
    let mut file = BufReader::new(File::open(path)?);
    file.read_to_end(&mut bytes)?;

    hash_algorithm(algorithm, &bytes)
}

/// Generates multiple TOTP codes from base32_seed, with time step +-tolerance
/// time_override is used as the current unix time instead of the current system time for testing
fn totp_generate_tolerance(
    algorithm: &str,
    base32_seed: &str,
    tolerance: i32,
    digits: usize,
    time_override: Option<i64>,
) -> Result<String> {
    let mut results: Vec<String> = Vec::new();
    for i in -tolerance..(tolerance + 1) {
        let result = totp_generate(algorithm, base32_seed, i.into(), digits, time_override)?;
        results.push(result)
    }
    Ok(serde_json::to_string(&results)?)
}

fn hmac<D>(seed: &[u8], data: &[u8]) -> Vec<u8>
where
    D: Mac + hmac::digest::KeyInit,
{
    let mut mac = <D as Mac>::new_from_slice(seed).unwrap();
    mac.update(data);
    mac.finalize().into_bytes().to_vec()
}

/// Generates a single TOTP code from base32_seed offset by offset time steps
/// base32_seed should be at least 16 input bytes, 128 bits, but is recommended to be 20 input bytes, 160 bits
/// Please use a proper hardware-seeded CSPRNG to seed the TOTP and store it in a secure location.
/// Maximum usable length of seed is 104 characters (64 bytes, 512 bits)
/// time_override is used as the current unix time instead of the current system time for testing
/// TOTP algorithm described https://blogs.unimelb.edu.au/sciencecommunication/2021/09/30/totp/
fn totp_generate(
    algorithm: &str,
    base32_seed: &str,
    offset: i64,
    digits: usize,
    time_override: Option<i64>,
) -> Result<String> {
    let mut seed: [u8; 64] = [0; 64];

    if base32_seed.len() < 16 || base32_seed.len() > 104 {
        return Err(Error::BadSeed);
    }
    if !(1..=8).contains(&digits) {
        return Err(Error::BadDigits);
    }

    match base32::decode(base32::Alphabet::Rfc4648 { padding: true }, base32_seed) {
        Some(base32_bytes) => {
            seed[..base32_bytes.len()].copy_from_slice(&base32_bytes);
        }
        None => return Err(Error::BadSeed),
    }
    // Will panic if the date is not between Jan 1 1970 and the year ~200 billion
    let curr_time: i64 = time_override.unwrap_or_else(|| {
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .expect("SystemTime is before Unix Epoc")
            .as_secs()
            .try_into()
            .unwrap()
    }) / TOTP_STEP_SECONDS;
    let time: u64 = (curr_time + offset) as u64;
    let time_bytes: [u8; 8] = time.to_be_bytes();

    let hmac_bytes: Vec<u8> = match algorithm {
        "sha1" => hmac::<Hmac<Sha1>>(&seed, &time_bytes),
        "sha256" => hmac::<Hmac<Sha256>>(&seed, &time_bytes),
        "sha512" => hmac::<Hmac<Sha512>>(&seed, &time_bytes),
        _ => return Err(Error::InvalidAlgorithm),
    };

    let offset: usize = (hmac_bytes[hmac_bytes.len() - 1] & 0x0F).into();

    let result_bytes: [u8; 4] = hmac_bytes[offset..(offset + 4)].try_into().unwrap();

    let full_result: u32 = u32::from_be_bytes(result_bytes);
    let result: u32 = (full_result & 0x7FFFFFFF) % DIGITS_POWER[digits];
    let mut result_str = result.to_string();
    if result_str.len() < digits {
        result_str = format!("{result_str:0>digits$}");
    }

    Ok(result_str)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn totp_generate_test() {
        // https://datatracker.ietf.org/doc/html/rfc6238 secret key at the top is wrong, read the code for seed32/seed64
        const TOTP_TEST_TIMES: [i64; 6] = [
            59,
            1111111109,
            1111111111,
            1234567890,
            2000000000,
            20000000000,
        ];
        const TOTP_TEST_ALGORITHMS: [&'static str; 3] = ["sha1", "sha256", "sha512"];
        const TOTP_TEST_SEEDS: [&'static str; 3] = [
            "12345678901234567890",
            "12345678901234567890123456789012",
            "1234567890123456789012345678901234567890123456789012345678901234",
        ];
        const TOTP_TEST_VALUES_TIME_ALGO: [[&'static str; 3]; 6] = [
            ["94287082", "46119246", "90693936"],
            ["07081804", "68084774", "25091201"],
            ["14050471", "67062674", "99943326"],
            ["89005924", "91819424", "93441116"],
            ["69279037", "90698825", "38618901"],
            ["65353130", "77737706", "47863826"],
        ];
        TOTP_TEST_TIMES
            .iter()
            .enumerate()
            .for_each(|(time_idx, time)| {
                TOTP_TEST_ALGORITHMS
                    .iter()
                    .zip(TOTP_TEST_SEEDS)
                    .enumerate()
                    .for_each(|(algo_idx, (algo, seed))| {
                        let totp = totp_generate(
                            *algo,
                            &base32::encode(
                                base32::Alphabet::Rfc4648 { padding: true },
                                seed.as_bytes(),
                            ),
                            0,
                            8,
                            Some(*time),
                        );
                        assert_eq!(
                            totp.unwrap(),
                            TOTP_TEST_VALUES_TIME_ALGO[time_idx][algo_idx]
                        );
                    })
            });

        // The big offset is so that it always uses the same time, allowing for verification that the algorithm is correct
        // Seed, time, and result for zero offset taken from https://blogs.unimelb.edu.au/sciencecommunication/2021/09/30/totp/
        let result = totp_generate(
            "sha1",
            "XE7ZREYZTLXYK444",
            0,
            6,
            Some(54424722i64 * TOTP_STEP_SECONDS + (TOTP_STEP_SECONDS - 1)),
        );
        assert_eq!(result.unwrap(), "417714");
        let result2 = totp_generate(
            "sha1",
            "XE7ZREYZTLXYK444",
            -1,
            6,
            Some(54424722i64 * TOTP_STEP_SECONDS + (TOTP_STEP_SECONDS - 1)),
        );
        assert_eq!(result2.unwrap(), "358747");
        let result3 = totp_generate(
            "sha1",
            "XE7ZREYZTLXYK444",
            1,
            6,
            Some(54424722i64 * TOTP_STEP_SECONDS + (TOTP_STEP_SECONDS - 1)),
        );
        assert_eq!(result3.unwrap(), "539257");
        let result4 = totp_generate(
            "sha1",
            "XE7ZREYZTLXYK444",
            2,
            6,
            Some(54424722i64 * TOTP_STEP_SECONDS + (TOTP_STEP_SECONDS - 1)),
        );
        assert_eq!(result4.unwrap(), "679828");

        let json_result = totp_generate_tolerance(
            "sha1",
            "XE7ZREYZTLXYK444",
            1,
            6,
            Some(54424722i64 * TOTP_STEP_SECONDS + (TOTP_STEP_SECONDS - 1)),
        );
        assert_eq!(json_result.unwrap(), "[\"358747\",\"417714\",\"539257\"]");
        let err_result = totp_generate_tolerance("sha1", "66", 0, 6, None);
        assert!(err_result.is_err());
        let err_result = totp_generate_tolerance("sha1", "XE7ZREYZTLXYK444", 0, 10, None);
        assert!(err_result.is_err());
        let err_result = totp_generate_tolerance("invalid", "XE7ZREYZTLXYK444", 0, 6, None);
        assert!(err_result.is_err());
    }
}
